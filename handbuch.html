<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8">
		<title>Castor Handbuch</title>
	</head>
	<body style="font-family:arial, helvetica, sans-serif;">
		<h1>Castor Handbuch</h1>
		<a href="#createDocument">Erste Schritte</a><br>
		<a href="#structure">Verzeichnisstruktur</a><br>
		<a href="#viewandtemplates">View und Templates</a><br>
		<a href="#returntypes">Returntypes</a><br>
		<a href="#phtml">PHTML Dokumente</a><br>
		<a href="#static">Statische Dokumente</a><br>
		<a href="#elements">Elemente und Konstanten</a><br>
		<a href="#sitemap">Sitemap</a><br>
		<a href="#pageandactions">Page & Action</a><br>
		<a href="#modules">AddOns, Plugins bzw. Module</a><br>
		<a href="#hooks">Hooks</a><br>
		<a href="#shortcuts">Shortcuts</a><br>
		<a href="#dependencys">Dependencys</a><br>
		<p>
			<a name="createDocument"></a>
			<h2>Dokument und Konfiguration Erstellen</h2>
			Die Kernaufgabe der Castor Komponenten ist es, eine MVC Struktur als Objekt Hierachie aufzubauen.<br>
			Damit die Anwendung nicht auf feste Namengebung und Verzeichnisstrukturen angewiesen ist,<br>
			wird die Hierachie in einer XML Datei definiert. Document Klassen sind auf eine Konfigurations-Datei angewiesen,<br>
			eine Hierachie kann aber auch mithilfe der Klassen Page und Action aufgebaut werden, mehr dazu im Kapitel <a href="#pageandactions">Page & Action</a><br><br>
			Die Konfiguration enth&auml;lt neben vielen m&ouml;glichkeiten zur Beschreibung der Struktur und Daten, folgende essentiellen Informationen.
			<ul>
				<li>Den Pfad zum Verzeichnis mit den PHP Dateien config -&gt; document -&gt; path</li>
				<li>Eine Standard Aktion die durchgeführt wird, wenn keine Parameter vorhanden sind config -&gt; document -&gt; root</li>
				<li>Eine Standard Datei mit einer Controller Klasse die in jedem Fall eingebunden wird config -&gt; document -&gt; file</li>
				<li>Den Tag f&uuml;r eine Sitemap der vorhanden sein muss und in der aktuellen Version auch mit einer Beschreibung der root Action gefüllt sein muss config -&gt; sitemap</li>
			</ul>
			<p>
			Die minimalste Config sieht aus wie folgt und sollte ausserhalb des Document Root Verzeichnis, lesbar für den Webserver abgelegt werden.<br>
			Der Ordner Castor kann im Document Root abgelegt werden, empfohlen sei es aber diesen ausserhalb und die config.xml als Datei innerhalb des Verzeichnisses castor/config/ abzulegen.<br>
			Wird beim initiallisieren der Seite keine config Datei angegeben, sucht das System im Verzeichniss config/ nach der Datei config.xml<br>
			Das bsp. wurde dort vorbereitet. Die Angabe der DTD ist zur Zeit überflüssig, da noch keine Document Type Definition für ein endgültiges Format exisiert.
			</p>
<pre style="padding:5px; background-color:lightgrey;">
&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;!DOCTYPE config&gt;
&lt;config&gt;
	&lt;document&gt;
		&lt;path&gt;controller&lt;/path&gt;
		&lt;root action="welcome"&gt;home&lt;/root&gt;
		&lt;file&gt;indexController.php&lt;/file&gt;
	&lt;/document&gt;
	&lt;sitemap&gt;
	&lt;/sitemap&gt;
&lt;/config&gt;
</pre>
<p>
1. Der Pfad zum Verzeichnis mit den PHP Dateien muss relativ zur instanizierenden PHP Datei sein. Typischerweise wohl die Datei index.php im Document Root des Webservers.<br>
2. Die Root Action muss innerhalb des unten beschriebenen sitemap tags definiert sein und bestimmt die Methode die aufgerufen wird, wenn keine Parameter an die Document Klassen übergeben werden.<br>
3. Die Angabe einer Root Action ist zwingend erforderlich und soll im bsp. die Action "welcome" in der Page "home" ansteuern.<br><br>
Die Datei im file Tag innerhalb des Document Tags wird für jede Action vererbt, die Angabe ist aber nicht zwingend erforderlich.<br>
Durch die Angabe der Dateien in höheren Hierachien wird zwar die Konfiguration übersichtlich gehalten,<br>
allerdings wird beim Aufruf einer Action die nicht innerhalb der Datei indexController.php definiert ist, diese trotzdem immer mit eingebunden.<br>
Der größte Vorteil der Castor Klassen gegnüber anderen Frameworks und Kern-Modellen ist, das durch die Konfiguration des Objekt Baumes immer nur die Klassen und Dateien eingebunden werden die zwingend nötig sind.<br>
Dieser Vorteil sollte in jedem Fall gewahrt bleiben.
</p>
Für ein einfaches bsp. muss die folgende Beschreibung im Node sitemap eingefügt werden:
<pre style="padding:5px; background-color:lightgrey;">
&lt;page name="home" index="welcome" return="DomDocument"&gt;
	&lt;class&gt;indexController&lt;/class&gt;
	&lt;method&gt;welcome&lt;/method&gt;
	&lt;action name="welcome"&gt;
		&lt;style renderby="client"&gt;/styles/welcome.xsl&lt;/style&gt;
	&lt;/action&gt;
&lt;/page&gt;
</pre>
<p>
Die Angabe eines "file" Tags wie oben ist sowohl im Tag page als auch im Tag action möglich.<br>
Ebenso können die Angaben der Tags "class" und "method" auch innerhalb des "action" Tags definiert oder wieder überschrieben werden.<br>
In typischen Strukturen finden sich die Action Methoden einer Page meist in einer Controller Klasse.<br>
In typischen bsp. würde man die "method" also in jedem action Tag definieren bzw. überschreiben und für die page eine gesamtgültige Datei mit einer Controller Klasse definieren.<br>
Im Bsp. wird die action /home/welcome auf die Methode "welcome" der Klasse "indexController" innerhalb einer eingebundenen Datei geroutet.<br>
In unserem bsp. ist nur eine allgemein eingebundene Datei im "document" Tag zu finden.<br>
Wird bspw. eine page "user" erstellt, kann man für schöne Verzeichnis Strukturen eine Datei mit dem Tag "file" im "page" Tag einbinden und den "method" Tag innerhalb des "action" Tags definieren<br><br>
Der Style Tag enthält die Datei mit einem Template, die erste Version von Castor wurde mit der Klasse "xsltDocument" geschrieben, die xsl Stylesheets nutzt.<br>
Wird der Objekt Baum mit der Klasse phtmlDocument instanziert, findet sich hier eine PHP Datei mit HTML inhalten oder ähnliches.
		</p>
		<p>
			<a name="structure"></a>
			<h2>Erstellung der Verzeichniss Struktur</h2>
			Die in der config angegeben Dateien und Pfade können relativ zur aufgerufenen PHP Datei oder mit einem führenden Slash absolut angegeben werden.<br>
			Die Verzeichnis Struktur wie hier sollte etwa wie folgt aussehen:
<pre style="padding:5px; background-color:lightgrey;">
DOCUMENTROOT
	/controller
		- indexController.php
	/styles
		- welcome.xsl
	/index.php
</pre>
			Die Datei die vom Webserver aufgerufen wird, wird im folgenden index.php genannt.
			<h2>Aufruf der Root Action</h2>
			Als Interface zum Framework stehen zwei Klassen zur Verfügung.<br>
			Die Klasse xsltDocument wurde primär für das erstellen von Dokumenten mit einem XSL Template erstellt aber kennt verschiedene Wege den VIEW zu füllen.<br>
			Die Klasse phtmlDocument, nutzt eine PHP Datei als Template und wird primär durch die statischen Methoden der Klasse View gefüllt.<br>
			Siehe folgender Code:<br>
<pre style="padding:5px; background-color:lightgrey;">
&lt;?php

$document = new xsltDocument();
$document->loadPage();
</pre>
			Nach dem initalen instanziieren der xsltDoument Klasse, wird durch loadPage() die Standard Aktion aufgerufen.<br>
			Als Standard wurde die Aktion welcome in der Seite home definiert: &lt;root action="welcome"&gt;home&lt;/root&gt;<br>
			indexController.php sollte angelegt werden und minimal mit folgenden Code gefüllt werden:
<pre style="padding:5px; background-color:lightgrey;">
&lt;?php
class indexController extends Application {
	public function welcome() {
		return false;
	}
}
</pre>
			Durch die Methode loadPage wird beim aufrufen der Seite www.meineseite.de/index.php jeder Request wie in der config angegeben nach indexController->welcome() geroutet.<br>
			Der Konstruktor der Klasse kann im aktuellen bsp. überschrieben werden aber muss ein Child der Klasse Application sein, welche die essentiellen Funktion des Frameworks zur verfügung stellt.
			<a name="viewandtemplates"></a>
			<h2>View und Templates</h2>
			Für die Action welcome im oberen bsp wurde ein xsl Stylesheet /styles/welcome.xsl angegeben. Die Elemente von xsltDocument müssen als XML Dokument erstellt werden.<br>
			Durch die Einstellung renderby="client" im style tag der Konfig wird das Framework angewiesen keine Elemente direkt zu rendern, sondern nur den Stylesheet als ProcessingInstruction in das Dokument einzufügen.<br>
			Da keine weiteren Definitionen vorgenommen wurden und der View mit keinen dynamischen Elementen gefüllt wurde, erhält der Browser folgende ausgabe:
<pre style="padding:5px; background-color:lightgrey;">
&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;?xml-stylesheet type="text/xsl" href="/styles/welcome.xsl"?&gt;
&lt;root&gt;&lt;/root&gt;
</pre>
			Alle g&auml;ngigen Browser sind xslt fähig, der Ursprungsgedanke von XML, nämlich nur Daten zu übertragen und diese in einem beliebigen Format zu rendern wurde aber fast von keinem Enterprise System umgesetzt.<br>
			Überlicherweise wird xslt zum rendern von PDF oder Excel Dokumenten genutzt, zur Geschichte von Castor gehört aber auch das xslt als primäre Template Engine eingesetzt wurde.<br>
			Wird im Stylesheet welcome.xsl also ein xsl Template wie folgt hinterlegt wird der Browser einen als h1 fomatieren String "Hello World" zur&uuml;ckgeben:
<pre style="padding:5px; background-color:lightgrey;">
&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;xsl:stylesheet version="1.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform"&gt;

&lt;xsl:output method="html"
    omit-xml-declaration="yes"
    encoding="UTF-8"
    indent="yes"
	doctype-system="about:legacy-compat"
/&gt;

&lt;xsl:template match="/"&gt;
&lt;html&gt;
	&lt;head&gt;
	&lt;/head&gt;
	&lt;body&gt;
		&lt;h1&gt;Hello World&lt;/h1&gt;
	&lt;/body&gt;
&lt;/html&gt;
&lt;/xsl:template&gt;

&lt;/xsl:stylesheet&gt;
</pre>
			Ergibt:
<pre style="padding:5px; background-color:lightgrey;">
&lt;!DOCTYPE html "about:legacy-compat"&gt;
&lt;html&gt;
	&lt;head&gt;
	&lt;/head&gt;
	&lt;body&gt;
		&lt;h1&gt;Hello World&lt;/h1&gt;
	&lt;/body&gt;
&lt;/html&gt;
</pre>
		</p>
		<p>
			Die Angabe von "server" im renderby Attribut des "style" Tags weist die xsltDocument Klasse an bei vorhandenem PHP-XSL Modul bereits beim Routing Prozess das Rendering zu übernehmen und es wird reines HTML gesendet.<br>
			Fans von xsl werden zwar häufig auf diese Methode zurückgreifen. Die Rechenzeit des Servers wird durch Template Preprozessoren aber belastet und auf dieser Seite hat das Clientseitige Rendern einen Vorteil.
		</p>
		<p>
			<a name="returntypes"></a>
			<h2>Returntypes</h2>
			Um Dynamische Daten einzufügen gibt es verschiedene Möglichkeiten.<br>
			Im Page Tag der Config findet sich oben der Parameter: return="DomDocument", was so viel bedeutet wie: "Die Methode des Controllers sollte ein Objekt vom Typ DomDocumentObj zurückgeben"<br>
			Das Attribut kann auch im action Tag folgen und überschrieben werden.
			Erstellt man ein Klasse wie hier:
<pre style="padding:5px; background-color:lightgrey;">
&lt;?php
class indexController extends Application {
	public function welcome() {
		$domDocumentObj = new DOMDocument('1.0', 'UTF-8');
		$ausgabeNode = $domDocumentObj->createElement('ausgabe');
		$txt = $domDocumentObj->createTextNode('Hello World');
		$ausgabeNode->appendChild($txt);
		$domDocumentObj->appendChild($ausgabeNode);

		return $domDocumentObj;
	}
}
</pre>
			Erhält man ein Ergebniss wie hier:
<pre style="padding:5px; background-color:lightgrey;">
&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;?xml-stylesheet type="text/xsl" href="/styles/welcome.xsl"?&gt;
&lt;root&gt;
	&lt;ausgabe&gt;Hello World&lt;/ausgabe&gt;
&lt;/root&gt;
</pre>
			Der Satz Hello World im Template kann nun also mit dynamischen Daten etwa so ausgegeben werden:
<pre style="padding:5px; background-color:lightgrey;">
&lt;xsl:template match="/"&gt;
&lt;html&gt;
	&lt;head&gt;
	&lt;/head&gt;
	&lt;body&gt;
		&lt;h1&gt;&lt;xsl:value-of select="//ausgabe" />&lt;/h1&gt;
	&lt;/body&gt;
&lt;/html&gt;
&lt;xsl:template&gt;
</pre>
			Verschiedene returntypes werden von den Dokumenten unterstützt:<br>
			<h3>xsltDocument</h3>
			<ul>
				<li>DomDocument</li>
				<li>Array</li>
				<li>json</li>
				<li>file</li>
			</ul>
			<h3>phtmlDocument</h3>
			<ul>
				<li>Array</li>
				<li>json</li>
				<li>file</li>
			</ul><br>
			Der ReturnType DomDocument ist zur Zeit nur mit der Klasse xsltDocument nutzbar.<br>
			Bei einer Rückgabe von json wird der Styletag komplett ignoriert, ohne Angabe eines "style" Tags wird angenommen das ein DomDocument Objekt zurückgegeben wird. Mit einer Methode wie:<br>
<pre style="padding:5px; background-color:lightgrey;">
&lt;?php
class indexController extends Application {
	public function welcome() {
		return false;
	}
}
</pre>
			Kann dies umgangen werden, alle Methoden die false liefern und nicht der returnType "file" angegeben ist, sind nicht auf einen "style" Tag angewiesen.<br>
			Gibt man für die action oder page die in der config Datei definiert wurde den ReturnType Array an, könnte das obrige bsp wie folgt aussehen:
<pre style="padding:5px; background-color:lightgrey;">
&lt;?php
class indexController extends Application {
	public function welcome() {
		return array('ausgabe' => 'Hello World');
	}
}
</pre>
			Startet man das selbe Programm mit dem returnType json, wird das Array hier schlichtweg als json Format codiert und der angegbene Stylsheet komplett ignoriert.<br>
			Komplexere XML Dokumente werden mit mehr dimensionalen Array erstellt Zwar sind angaben wie:
<pre style="padding:5px; background-color:lightgrey;">
	$arr['ausgabe']['text'] = "Hello World";
	$arr['ausgabe']['name'] = "Mein Name";
</pre>
			Primitiv und korrekt, wenn aber mehrere Datensätze zu einem Element benötigt werden, muss die folgende Dimension immer durch eine Zahl identfiziert werden:
<pre style="padding:5px; background-color:lightgrey;">
	$arr['freund'][0]['id'] = "1";
	$arr['freund'][0]['name'] = "Sein Name 1";
	$arr['freund'][1]['id'] = "2";
	$arr['freund'][1]['name'] = "Sein Name 2";
</pre>
			Wird dieses Array vom Controller zurückgegeben, der returnType mit Array angegeben und der Controller durch xsltDocument instanziert erh&auml;lt man folgendes Ergebniss:
<pre style="padding:5px; background-color:lightgrey;">
&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;?xml-stylesheet type="text/xsl" href="/styles/welcome.xsl"?&gt;
&lt;root&gt;
	&lt;freund&gt;
		&lt;id&gt;1&lt;/id&gt;
		&lt;name&gt;Sein Name 1&lt;/name&gt;
	&lt;/freund&gt;
	&lt;freund&gt;
		&lt;id&gt;2&lt;/id&gt;
		&lt;name&gt;Sein Name 2&lt;/name&gt;
	&lt;/freund&gt;
&lt;/root&gt;
</pre>
		Ohne angabe eines Stylesheets und keiner Angabe des Returntypes, versucht Castor aus einem DomDocument Objekt eine reine xml Datei mit passenden Header zu generieren.
		</p>
		<p>
			<a name="phtml"></a>
			<h2>phtmlDocument</h2>
			Vor allem mit dem aussterben von xhtml/strict HTML Seiten wird xsl beinah ausschliesslich zum exportieren und transformieren in andere Formate verwendet.<br>
			Als alternative zu xsl Stylesheets kann eine PHP Datei verwendet werden. Der Controller muss dazu durch die Klasse phtmlDocument instanziiert werden:
<pre style="padding:5px; background-color:lightgrey;">
&lt;?php

$document = new phtmlDocument();
$document->loadPage();
</pre>
			Wählt man den return type Array wie oben, kann das gesamte Array durch die statische Klasse View angesprochen werden, ein phtml Stylesheet für dieses bsp. k&ouml;nnte wie folgt aussehen:
<pre style="padding:5px; background-color:lightgrey;">
&lt;html&gt;
	&lt;head&gt;
	&lt;/head&gt;
	&lt;body&gt;
		&lt;h1&gt;&lt;? echo View::get('ausgabe'); &gt;&lt;/h1&gt;
	&lt;/body&gt;
&lt;/html&gt;
</pre>
Phtml Doumente müssen nicht zwangsläufig ein gefülltes Array zurückgeben. Der Klasse View kann auch während der Laufzeit des Contollers, ein Wert übergeben werden:
<pre style="padding:5px; background-color:lightgrey;">
&lt;?php
class indexController extends Application {
	public function welcome() {
		View::add("ausgabe", "Hello World");

		return array();
	}
}
</pre>
		</p>
		<p>
			<a name="static"></a>
			<h2>Statische Webseiten</h2>
			Oft wird ein PHP-Programm für öffentliche Webseiten ohne Funktion, CMS, Fehlermeldungen und andere Dynamische Inhalte nur eingesetzt um bspw. den Aufruf zu protokollieren oder ein Cookie zu setzen.<br>
			Solche Dokumente k&ouml;nnen durch den returnType "file" unabhängig von Designern erstellt werden.<br>
			Der returnType "file" steht sowohl als phtmlDocument als auch als xsltDocument instanziierten Dokumenten zur verfügung.<br>
			Das Framework erkennt früh wenn der returnType File angegeben wird und erzeugt so den geringsmöglichen overhead beim Routing und der Ausgabe.
<pre style="padding:5px; background-color:lightgrey;">
&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;!DOCTYPE config&gt;
&lt;config&gt;
	&lt;document&gt;
		&lt;path&gt;controller/&lt;path&gt;
		&lt;root action="welcome"&gt;home&lt;/root&gt;
		&lt;file&gt;indexController.php&lt;/file&gt;
	&lt;/document&gt;
	&lt;sitemap&gt;
		&lt;page name="home" index="welcome" return="DomDocument"&gt;
			&lt;class&gt;indexController&lt;/class&gt;
			&lt;method&gt;welcome&lt;/method&gt;
			&lt;action name="welcome"&gt;
				&lt;style renderby="client"&gt;/styles/welcome.xsl&lt;/style&gt;
			&lt;/action&gt;
			&lt;action name="impressum" return="file"&gt;
				&lt;class&gt;simpleController&lt;/class&gt;
				&lt;method&gt;impressum&lt;/method&gt;
				&lt;file&gt;simpleController.php&lt;/file&gt;
				&lt;style&gt;/styles/impressum.html&lt;/style&gt;
			&lt;/action&gt;
		&lt;/page&gt;
	&lt;/sitemap&gt;
&lt;/config&gt;
</pre>
			Wird eine solche config.xml angelegt wird die action impressum der Seite home hinzugefügt. Man beachte das, das Attribut return aus dem page Tag, die Datei aus dem document-&gt;file Tag, als auch die Klasse und Methode &uuml;berschrieben wurden.<br>
			Dieses vorgehen ist üblich da zwar default Werte gesetzt sein sollten, das Routing auf andere Seiten und Klassen aber im MVC Modell zur Strukturierung des Codes eingesetzt wird.<br>
			Der style Tag wurde nicht mit einem renderby attribut versehen.<br>
			Für dieses bsp. muss eine neue Datei controller/simpleController.php mit bspw. folgendem Inhalt angelegt werden:
<pre style="padding:5px; background-color:lightgrey;">
&lt;?php
class simpleController extends Application {
	public function impressum() {
		// Setzen sie einen Cookie
		// Stellen sie eine DB Verbindung her und speichern sie etwas
		// oder anderes

		return false;
	}
}
</pre>
			Als Stylesheet wird im ordner styles, eine Datei namens impressum.html hinterlegt die ohne dynamische Inhalte und overhead an den Browser gesendet wird. Der Content Type entspricht dabei: text/html<br>
			Da unsere Datei index.php jetzt nicht die root Seite der Homepage aufrufen soll, muss diese wie folgt modifiziert werden:
<pre style="padding:5px; background-color:lightgrey;">
&lt;?php

$document = new phtmlDocument();
$document->loadPage('home', 'impressum');
</pre>
			Als erster Parameter wird die Page übergeben, als zweiter die action. Wird nur die page übergeben, wird die action geladen die im index attribut des page Tags angegeben wurde.
			Typisch für MVC organisierte PHP Programme ist der Aufruf mit einem Page und Action Parameter der oft mit redirect Modulen der Webserver in SEO-Urls umgewandelt wird.
<pre style="padding:5px; background-color:lightgrey;">
&lt;?php

$page = false;
$action = false;
if(array_key_exists('page', $_GET)
	$page = $_GET['page'];
if(array_key_exists('action', $_GET)
	$action = $_GET['action'];

$document = new phtmlDocument();
$document->loadPage($page, $action);
</pre>
		</p>
		<p>
			<a name="elements"></a>
			<h2>Elemente und Konstanten</h2>
			Ein großer Vorteil einer komplexen Konfiguration wie hier, ist nicht nur das die Beschreibung der Struktur auch für Projekt Neulinge offensichtlich lesbar und ohne Namenskonventionen ersichtlich ist,
			sondern vor allem das weitere Elemente zur Beschreibung einer Action hinzugefügt werden können.
			Innerhalb des document tags, des page tags oder des action tags können Konstanten und Variablen definiert werden, die durch das Framework zugänglich gemacht werden.
			Der arr Tag beginnt eine Sammlung von Variablen die mit dem var tag innerhalb des arr Tags angelegt werden.
			Der Einsatz von var Elementen ohne umschliessenden arr tag wird zurzeit nicht unterstützt.
			Wenn die Datei config xml unzugänglich abgelegt wird, können so bspw. System Konstanten durch den Administrator eingetragen und geändert werden.
<pre style="padding:5px; background-color:lightgrey;">
&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;!DOCTYPE config&gt;
&lt;config&gt;
	&lt;document&gt;
		&lt;path&gt;controller/&lt;path&gt;
		&lt;root action="welcome"&gt;home&lt;/root&gt;
		&lt;file&gt;indexController.php&lt;/file&gt;
	&lt;/document&gt;
	&lt;sitemap&gt;
		&lt;page name="home" index="welcome" return="DomDocument"&gt;
			&lt;class&gt;indexController&lt;/class&gt;
			&lt;method&gt;welcome&lt;/method&gt;
			&lt;action name="welcome"&gt;
				&lt;style renderby="client"&gt;/styles/welcome.xsl&lt;/style&gt;
			&lt;/action&gt;
			&lt;action name="impressum" return="file"&gt;
				&lt;arr name="dbConstants"&gt;
					&lt;var name="dbname">dbname&lt;/var&gt;
					&lt;var name="host">127.0.0.1&lt;/var&gt;
					&lt;var name="username">dbuser&lt;/var&gt;
					&lt;var name="password">dbpassword&lt;/var&gt;
				&lt;/arr&gt;

				&lt;class&gt;simpleController&lt;/class&gt;
				&lt;method&gt;publicPage&lt;/method&gt;
				&lt;file&gt;simpleController.php&lt;/file&gt;
				&lt;style&gt;/styles/impressum.html&lt;/style&gt;
			&lt;/action&gt;
		&lt;/page&gt;
	&lt;/sitemap&gt;
&lt;/config&gt;
</pre>
			Im diesem bsp. wird der action impressum ein array mit konstanten übergeben die später mit der Methode getElements der Application Klasse für den Entwickler zugänglich sind:
<pre style="padding:5px; background-color:lightgrey;">
&lt;?php
class simpleController extends Application {
	public function publicPage() {
		$dbdata = $this->getElements('dbConstants');

		die("Jetzt eine Datenbankverbindung mit: ".$dbdata['host']." dem user: ".$dbdata['username']." und dem Passwort: ".$dbdata['password']." aufbauen");

		return false;
	}
}
</pre>
			So kann bspw. der Datenbank Server umziehen oder das Passwort geändert werden, ohne im Programm müsam nach den Nutzerdaten suchen zu müssen.<br>
			Die Klasse xsltDocument kann ausserdem mithilfe des expand Tags Konstanten für document, page oder action definieren die ohne hinzufügen zum View mit in das xml Dokument einfliessen
<pre style="padding:5px; background-color:lightgrey;">
&lt;expand node="upperLevel"&gt;
	&lt;add name="lowerLevel"&gt;Hello World&lt;/add&gt;
&lt;/expand&gt;
</pre>
			Eingefügt in der Config ohne weitere Elemente aus dem View und dem returnType: xml, sendet ein xml Dokument wie:
<pre style="padding:5px; background-color:lightgrey;">
&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;upperLevel&gt;
	&lt;lowerLevel&gt;Hello World&lt;/lowerLevel&gt;
&lt;/upperLevel&gt;
</pre>
		</p>
		Die Document Klasse, phtmlDocument, ignoriert die angabe von "expand" Tags.<br>
		<p>
			<a name="createDocument"></a>
			<h2>Sitemaps</h2>
			<p>
				In der WEB 1.0 Welt, waren Sitemaps und Breadcrum Navigationen eine musthave Information für die Benutzer.<br>
				Aber auch heute sind Webseiten durch eine Hauptnavigation und oft Submenüs steuerbar.<br>
				Castor erstellt beim parsen der Konfiguration automatisch ein abbild der Page und Action Struktur und stellt diese bei Bedarf über die Application Klasse zur verfügung.
			</p>
<pre style="padding:5px; background-color:lightgrey;">
&lt;?php
class indexController extends Application {
	public function welcome() {
		// Create DomDocument Object
		$domDocumentObj = new DOMDocument('1.0', 'UTF-8');
		$domDocumentObj->preserveWhiteSpace = false;
		$domDocumentObj->formatOutput = false;

		// Add sitemap nodes
		if($elementSitemap = $this->getSitemap(false)) {
			$node = $domDocumentObj->importNode($elementSitemap, true);
			$domDocumentObj->appendChild($node);
		}

		return $domDocumentObj;
	}
}
</pre>
Ein Code wie hier fordert die erstellte Sitemap als DomDocumentElement Objekt an und importiert diesen in das DomDocument Objekt.<br>
Nach der Angabe des Attributes "title" im "page" und "action" Tag der Konfiguration:
<pre style="padding:5px; background-color:lightgrey;">
&lt;page title="www.xxx.de" name="home" index="welcome" return="DomDocument"&gt;
	&lt;action title="Startseite" name="welcome"&gt;
		&lt;style renderby="client"&gt;/styles/welcome.xsl&lt;/style&gt;
	&lt;/action&gt;
&lt;/page&gt;
</pre>
<p>Könnte der Aufruf von loadPage mit der Klasse xsltDocument, eine Ausgabe wie hier erzeugen:</p>
<pre style="padding:5px; background-color:lightgrey;">
&lt;sitemap&gt;
	&lt;page active="true"&gt; &lt;name&gt;home&lt;/name&gt;
		&lt;title&gt;www.xxx.de&lt;/title&gt;
		&lt;index&gt;index&lt;/index&gt;
		&lt;action active="true"&gt; &lt;title&gt;Startseite&lt;/title&gt;
			&lt;name&gt;index&lt;/name&gt;
			&lt;index&gt;index&lt;/index&gt;
		&lt;/action&gt;
	&lt;/page&gt;
&lt;/sitemap&gt;
</pre>
<p>
	Mithilfe eines Stylesheets lässt sich so eine Hauptnavigation für die gesamte Website Global definieren.<br>
	Der Status des Attributes "active" ist abhängig von der angesteuerten Action.<br>
	Ein Stylesheet wie:
<pre style="padding:5px; background-color:lightgrey;">
&lt;xsl:template match="/"&gt;
&lt;html&gt;
	&lt;head&gt;
	&lt;/head&gt;
	&lt;body&gt;
		&lt;xsl:apply-templates match="//sitemap" /&gt;
	&lt;/body&gt;
&lt;/html&gt;
&lt;xsl:template&gt;

&lt;xsl:template match="sitemap"&gt;
	&lt;nav&gt;
		&lt;xsl:for-each select="page"&gt;
		&lt;a&gt;
			&lt;xsl:attribute name="href"&gt;www.xxx.de?page=&lt;xsl:value-of select="name" /&gt;&lt;/xsl:attribute&gt;
		&lt;/a&gt;&lt;br /&gt;
		&lt;/xsl:for-each&gt;
	&lt;/nav&gt;
&lt;/xsl:template&gt;
</pre>
</p>
<p>
Könnte bspw. eine für jede Seite einheitliche Hauptnavigation zeichnen.<br>
Ein guter Trick ist es den name der Page oder Action als Teil einer CSS Klasse zu verwenden und so für jede Seite einen Button mit bspw. einem Hintergrundbild und hover zu stylen.<br><br>
Mit:
<pre style="padding:5px; background-color:lightgrey;">
$this->getSitemapArray();
</pre>
Kann die Sitemap auch als Array abgerufen werden und so innerhalb des Codes z.B. zur Rechteverwaltung genutzt werden.<br>
Die Sitemap begründet sich nicht als Feature, hat sich bei der erstelltung von Haupt/Sub und Breadcrum Navigationen aber als nützlich erwiesen, mehr im nächsten Kapitel <a href="#pageandactions">Page & Action</a><br>
Zusätzlich zu Elementen, kann innerhalb des "page" oder "action" Tags, mithilfe des Tags "constant" ein weiterer Wert in die Sitemap aufgenommen werden.<br>
Dieser kann bspw. genutzt werden um Seiten im Hauptmenü zu verstecken oder zu Highlighten.
		</p>
		<p>
			<a name="pageandactions"></a>
			<h2>Page & Action</h2>
			<p>
				Im Insider Handbuch kann die Geschichte und die Ziele des Projekts Castor nachgelsen werden,<br>
				an dieser Stelle sei nur gesagt das es verschiednene Itensionen gab das Projekt anzufangen.<br>
				<!--
				Das aufbauen einer Skeleton Applikation die in vielen Frameworks diskutiert werden muss, entspricht oft einem weiteren Zeitfaktor beim erlernen des Umgangs mit der Struktur der Website.<br>
				Namenskonventionen müssen erlernt werden und durch alle Mitarbeiter Konsequent umgesetzt werden.<br>
				Die Trennung von Daten durch ein Model ist oft nicht konsequent umgesetzt und komplexe Template Systeme in PHP oder JavaScript werden zur Darstellung herrangezogen.<br>
				Das PHP schon für sich genommen ein Template System ist, wird in MVC Modellen oft mit View und Controller vermischt und in Browsern oder Modulen nativ implementierte Template Systeme,<br>
				werden fast nie genutzt.<br>
				Durch eine XML Konfiguration, kann sowohl ein MVC Modell beschrieben werden als auch Daten vorbereitet und Kernelemente Seitenübergreifend vordefiniert werden.<br>
				-->
				Den Kern des Objekt Baumes bilden Instanzen der Klassen Page und Action die, von aussen auch direkt angesprochen werden können.<br>
				Zwar liegt der Schwerpunkt von Castor auf der Konfiguration des Objekt Baumes, aber auch händisch lassen sich Programmodelle mit diesen Klassen aufbauen.<br>
				Im beiglegten bsp. findet man einen kurzen Code in den Kommentaren als Alternative zu minimaler Konfiguration:<br>
				<pre style="padding:5px; background-color:lightgrey;">
$page = new Page('home', 'index');
$page->addFile('controller/indexController.php');
$page->setElement('myelement', array('element' => 'Hello World'));
$page->addAction('index', 'controller/indexController.php', 'indexAction');
$page->loadPage('home', 'index');
				</pre>
				Beim Parsen der Konfiguration beschränkt sich der Kern ähnlich wie hier auf den minimalsten Objekt Baum der nötig ist um loadPage ausführen zu können.<br>
				Im günstigsten Fall, beschränkt sich der Kern auf den bsp. Code um die essentiellen Daten für den Router bereitzustellen wenn eine Action geladen wird.<br>
				Durch die Methode addAction instanziiert das Page Objekt ein Objekt der Klasse Action und vererbt alle Variablen und Konstanten an dieses Objekt.<br>
				Die minimale Code Basis um eine Methode im Controller aufzurufen sieht intern also aus wie etwa hier:
				<pre style="padding:5px; background-color:lightgrey;">
require_once('controller/simpleController.php');
$action = new Action('impressum', 'indexController.php', 'impressum');
$action->run();
				</pre>
				Das Attribute returnType, rendering und der "stylesheet", werden vom Doucment an Page bis Action zwar vererbt werden aber erst durch die Document Klasse mit loadPage wieder ausgewertet.<br>
				Beim Aufruf der einzelnen Objekte wird daher keine Output Conversion stattfinden. Bei Controller Klasse die wie vorgegeben von der Application Klasse erben,<br>
				Werden aber alle Elemente vererbt. Ein Element setzt man bspw. mit Page->setElement($name, $arr) welches beim Aufruf von addAction auf die Action vererbt wird.<br>
				Die Intension nur das zu tun was tatsächlich angewiesen wird dadurch verdeutlicht, das auch die Klasse Action eine Methode setElement($name, $arr) behrbergt.<br>
				Mehr dazu in der Funktionsreferenz.<br>
			</p>
		</p>
		<p>
			<a name="modules"></a>
			<h2>AddOns, Plugins bzw. Module</h2>
			<p>
				Kein Programm Model kommt ohne erweiterbare Strukturen aus. Das AddOn Model von Castor setzt dem Paradigma entsprechend, auf die bestmögliche Effizienz beim Einbinden und Aufrufen der AddOns.<br>
				Um wiederkehrende Aufgaben zu modularisieren stellt Castor einige Abstrakte Klassen bereit, die sich nahtlos in den Objekt Baum einfügen und instanzen abgerufen werden können.<br>
				Das Einfachste Model das sich findet ist die Klasse "Adapter", die eine Integration externer Bibliotheken in den Controllern ermöglichen soll.<br>
				Da das AddOn Konzept noch relativ einfach gehalten ist, können selbst Anfänger mit einem Blick in die Datei src/adapter.php einen kurzen überblick über das Format gewinnen.<br>
				Alle AddOn Modelle implementieren die Methode "load", eine methode "setError" sowie getError, und verlangen das implementieren einer Methode init() und erbt wie die Controller,<br>
				von der Klasse Application. Ein einfacher Adapter könnte etwa so aussehen:
				<pre style="padding:5px; background-color:lightgrey;">
&lt;?php
class helloWorld extends Adapter {
	private $variables;

	public function init() {
		$this->variables = (object) $this->getElements('variables');

		return true;
	}

	public function getOutput() {
		return $this->variables->satz;
	}
}
				</pre>
				Ein AddOn muss durch die Konfiguration im "document" Tag vorbereitet und durch den Tag "load" geladen werden.<br>
<pre style="padding:5px; background-color:lightgrey;">
&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;!DOCTYPE config&gt;
&lt;config&gt;
	&lt;document&gt;
		&lt;path&gt;controller&lt;/path&gt;
		&lt;root action="welcome"&gt;home&lt;/root&gt;
		&lt;file&gt;indexController.php&lt;/file&gt;
		&lt;adapter name="helloWorld"&gt;
			&lt;arr name="variables"&gt;
				&lt;var name="satz"&gt;Dies kommt vom Adapter&lt;/var&gt;
			&lt;/arr&gt;
			&lt;file&gt;modules/helloworldAdapter.php&lt;/file&gt;
			&lt;class&gt;helloWorld&lt;/class&gt;
		&lt;/adapter&gt;
	&lt;/document&gt;
	&lt;sitemap&gt;
		&lt;page name="home" index="welcome" return="DomDocument"&gt;
			&lt;class&gt;indexController&lt;/class&gt;
			&lt;method&gt;welcome&lt;/method&gt;
			&lt;action name="welcome"&gt;
				&lt;load&gt;helloWorld&lt;/load&gt;
				&lt;style renderby="client"&gt;/styles/welcome.xsl&lt;/style&gt;
			&lt;/action&gt;
		&lt;/page&gt;
	&lt;/sitemap&gt;
&lt;/config&gt;
</pre>
Die Elemente respektive "arr" und "var" Tags sind für alle Instanzen des Moduls gültig und enthalten typischerweise Zugangsdaten wie Benutzernamen und Passwörter oder Variablen zum umschalten von Test auf Live Modus.<br>
Die Elemente werden nicht wie bei "arr" Tags im "page" oder "action" Tag vererbt sondern beim Aufruf einer Action oder Page mit einem "load" Tag an die Klasse "Module" übergeben.<br>
Die Definition des AddOns im "document" Tag nimmt also die Konfiguration auf, das Modul steht dem Controller aber nur zur verfügung, wenn für die Action ein "load" Tag vererbt wurde.<br>
Da alle Module wie Controller von der Klasse "Application" erben, kann in Modulen mit den Methoden der "Application Klasse", auf alle Variablen die an die instanzierende Action vererbt oder global gesetzt werden zugegriffen werden.<br>
Ergänzt man den "action" Tag also mit weiteren "arr" und "var" Elementen stehen diese dem Modul zur Verfügung, wenn diese innerhalb der methode der Action geladen werden.
<pre style="padding:5px; background-color:lightgrey;">
&lt;?php
class indexController extends Application {
	public function welcome() {
		// Create DomDocument Object
		$domDocumentObj = new DOMDocument('1.0', 'UTF-8');
		$domDocumentObj->preserveWhiteSpace = false;
		$domDocumentObj->formatOutput = false;

		// Add sitemap nodes
		if($elementSitemap = $this->getSitemap(false)) {
			$node = $domDocumentObj->importNode($elementSitemap, true);
			$domDocumentObj->appendChild($node);
		}

		$helloWorldModule = module::get('helloWorld', $this);

		$ausgabeNode = $domDocumentObj->createElement('ausgabe');
		$txt = $domDocumentObj->createTextNode($helloWorldModule->getOutput());
		$ausgabeNode->appendChild($txt);
		$domDocumentObj->appendChild($ausgabeNode);

		return $domDocumentObj;
	}
}
</pre>
Die Methode init() im Adapter, muss true zurückgeben, andernfallse wird eine Exception den Inhalt von application->getError() auswerfen.<br>
Sollten bspw. essentielle Parameter nicht definiert worden sein, kann mit setError() ein Fehler gesetzt werden und schon in init() der Aufruf des Moduls verhindert werden.<br>
Seid Version 1.0 Stable steht ist es möglich auch im Programmcode Parameter entegenzunehmen.<br>
Adapter implementieren hierzu die Methode "onReady":
				<pre style="padding:5px; background-color:lightgrey;">
&lt;?php
class helloWorld extends Adapter {
	private $variables;
	private $param = "Not set";

	public function init() {
		$this->variables = (object) $this->getElements('variables');
	}

	public function onReady($meinParameter = false) {
		if($meinParameter) {
			$this->param = $meinParameter;
		}

		return true;
	}

	public function getOutput() {
		return $this->variables->satz." ".$this->param;
	}
}
				</pre>
				Wird das Modul nun wie folgt geladen, wird der Parameter mit in die Ausgabe übernommen:
				<pre style="padding:5px; background-color:lightgrey;">
&lt;?php
class indexController extends Application {
	public function welcome() {
		// Create DomDocument Object
		$domDocumentObj = new DOMDocument('1.0', 'UTF-8');
		$domDocumentObj->preserveWhiteSpace = false;
		$domDocumentObj->formatOutput = false;

		// Add sitemap nodes
		if($elementSitemap = $this->getSitemap(false)) {
			$node = $domDocumentObj->importNode($elementSitemap, true);
			$domDocumentObj->appendChild($node);
		}

		$helloWorldModule = module::get('helloWorld', $this, "Meine neue Ausgabe");

		$ausgabeNode = $domDocumentObj->createElement('ausgabe');
		$txt = $domDocumentObj->createTextNode($helloWorldModule->getOutput());
		$ausgabeNode->appendChild($txt);
		$domDocumentObj->appendChild($ausgabeNode);

		return $domDocumentObj;
	}
}
				</pre>
				Jeder Parameter grö&szlig;er dem 3. von module::get() wird direkt an die Methode onReady übergeben nachdem init() erfolgreich durch die Klasse "module" aufgerufen wurde.<br>
				Sollten mehr Parameter angegeben werden als onReady aufnehmen will, werden diese ignoriert!
			</p>
		</p>
		<p>
			<h2>Plugins</h2>
			<p>
				Erste Plugins wurden als Module realisiert die ihrerseits grundlegende Funktionen implementieren und durch vererben zur verfügung stellen.
				Plugins werden Manuell im Programm eingebunden, so wird auch hier sichergestellt das nur benötigte Funktionen abgelegt und interpretiert werden müssen.
				Im Ordner Plugins findet man zu diesem Zeitpunkt ein Plugin zum session Management in PHP. Typische Sicherheitsmaßnahmen und Techniken aus den unterschiedlichsten Quellen wurden hierfür gesammelt.
<pre style="padding:5px; background-color:lightgrey;">
&lt;?php

define("RESET_CONFIG", true);

abstract class sessionManagement extends Operator {
	public $rights;
	private $token = false;
	private $hashAlgorythm = 'md5';
	private $constants;
	private $lastSessionId;

	public $fixRemoteAddr = false;
	public $fixUserAgent = false;
	public $maxLivetime = false;
	public $forwardSecrecy = false;
	public $sessionTimeoutSec = 1440;

	public $helpText = "The Plugin sessionManagement, opens a session on init and respects common security behaivors! Typical constants of the PHP installation will overwriten on init, set constant RESET_CONFIG to false to skip that.";
	public $helpParameters = array(
		'constants' => array(
			'fixremoteaddr' => "If 'yes', the session will destroyed, if the REMOTE_ADDR was changed. Mobile connections couldt ran into it!",
			'fixuseragent' => "If 'yes', the session will destroyed, if the HTTP_USER_AGENT header was changed. Mobile browsers changes his header with functions like: show desktop version and couldt ran into it!",
			'maxlifetime' => "If 'yes', a sessionId will regenerated after session.gc_maxlifetime in seconds",
			'forwardsecrecy' => "If 'yes', the available hash algorythms of the php installation will searched through the strongest sha encryption to use for the session. Not available on PHP >= 7.1"
		)
	);

	public $helpMethods = array(
		'session_started' => "check if a session was started, parameters: none",
		'session_save_start' => "recreates a sessions with known constants set, parameters: none",
		'session_destroy' => "unset session variables, session cookies and destroyes the session on server side, parameters: none"
	);

	public function init() {
		if(ini_get('session.gc_maxlifetime') > 0)
			$this->sessionTimeoutSec = ini_get('session.gc_maxlifetime');
		$this->constants = (object) $this->getElements('constants');

		if($this->constants) {
			if(isset($this->constants->fixremoteaddr) && $this->constants->fixremoteaddr == 'yes')
				$this->fixRemoteAddr = true;
	.....
</pre>
				Plugins unterscheiden sich in keinster Weise von Modulen, sollten aber die abstracten Methoden, des Modul Typs selbst implementieren.<br>
				Wie oben zusehen erbt die Klasse vom Modul Typ Operator (Anm. der wohl als erstes wieder rausfliegt)<br>
				Die Grundlegend essentielle und einheitliche Methode für Module ist die Methode init()!<br>
				Da alle Module wie Controller von der Klasse "Application" Erben steht vor allem hier auch die Methode $this->getElements() zur verfügung.<br>
				Das Plugin prüft den arr Tag "constants" der Definition und übernimmt die Parameter für spätere Funktionen.<br>
				Um auch dritten die Veröffentlichung von Plugins zu ermöglichen, kann im oberen Teil in namentlich fetgehaltenen Variablen das grundlegende Verhalten dokumentiert werden.<br>
				Die Dokumentation der Klasse mit $helpText, $helpParameters, und $helpMethods ist kein Musthave und muss sich bewähren, aber es sollte eine brauchbare Ergänzung sein,<br>
				wenn dritte ein Plugin veröffentlichen.
<pre style="padding:5px; background-color:lightgrey;">
&lt;?php

die(module::help('moduleName'));
</pre>
				Gibt die oben definierten Variablen formatiert aus und beschreibt so seine Funktion, die Methoden die zur verf&uuml;gung stehen und die Parameter die gesetzt werden k&ouml;nnen / m&uuml;ssen.<br>
<pre style="padding:5px; background-color:lightgrey;">
&lt;?php

require_once('Castor.php');
require_once('plugins/sessionManagement.php');
try {
	$document = new xsltDocument();
	$document->loadPage();
} catch(Exception $exeption) {
	die($exeption->getMessage());
}
</pre>
				Erlaubt es natürlich von der Eingebundenen Klasse die als Modul entworfen wurde zu erben und ein eigenes kleineres Modul zu schreiben.
				Ein Modul wie dieses, nehmen wir an in userManagement.php implementiert:
<pre style="padding:5px; background-color:lightgrey;">
&lt;?php

class userManagement extends sessionManagement {
	private $username;
	private $userpassword;

	public function onReady() {
		$logindata = (object) $this->getElements('loginData');
		$this->username = $logindata->user;
		$this->userpassword = $logindata->password;
	}

	public function login($name, $password) {
		if($name == $this->username && $password == $this->userpassword)
			die("Hurray iam loggedIn")
	}

	public function onRegenerate($session_id) {
		trigger_error("SessionID regenarated to ".session_id());
	}
}

</pre>
				Module die von Plugins ableiten sollen natürlich keine eigene Methode init() implementieren.<br>
				Anstatt dessen könnten Plugins das implementieren einer Methode, wie onRegenrate() erlauben.<br>
				Das Plugin führt diese immer aus wenn die SessionID erneuert wird.<br>
				Das übergeben von Parametern an onReady sollten Plugins allerdings dem Programmierer des Moduls überlassen.<br>
				Nur über diese Funktion und individuelle Elemente die der Action vererbt werden, kann der Programmierer sein Modul implizit mit dynamischen Variablen aufrufen.
<pre style="padding:5px; background-color:lightgrey;">
&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;!DOCTYPE config&gt;
&lt;config&gt;
	&lt;document&gt;
		&lt;path&gt;controller&lt;/path&gt;
		&lt;root action="welcome"&gt;home&lt;/root&gt;
		&lt;file&gt;indexController.php&lt;/file&gt;
		&lt;operator name="usermng"&gt;
			&lt;arr name="constants"&gt;
				&lt;var name="forwardsecrecy"&gt;yes&lt;/var&gt;
			&lt;/arr&gt;
			&lt;file&gt;modules/userManagement.php&lt;/file&gt;
			&lt;class&gt;userManagement&lt;/class&gt;
		&lt;/operator&gt;
	&lt;/document&gt;
	&lt;sitemap&gt;
		&lt;page name="home" index="welcome"&gt;
			&lt;class&gt;indexController&lt;/class&gt;
			&lt;method&gt;welcome&lt;/method&gt;
			&lt;action name="welcome"&gt;
				&lt;arr name="loginData"&gt;
					&lt;var name="user"&gt;test&lt;/var&gt;
					&lt;var name="password"&gt;test&lt;/var&gt;
				&lt;/arr&gt;
				&lt;load&gt;usermng&lt;/load&gt;
			&lt;/action&gt;
		&lt;/page&gt;
	&lt;/sitemap&gt;
&lt;/config&gt;
</pre>
				Die Konfiguration hier definiert das Modul userManagement das wie oben zu sehen vom Plugin sessionManagement erbt.<br>
				Ohne die Funktionen des Plugins genauer zu nennen sei gesagt das session_start() zu diesem Zeitpunkt schon ausgeführt wurde.<br>
				Ein Controller Code wie hier:
				<pre style="padding:5px; background-color:lightgrey;">
&lt;?php
class indexController extends Application {
	public function welcome() {
		// Create DomDocument Object
		$domDocumentObj = new DOMDocument('1.0', 'UTF-8');
		$domDocumentObj->preserveWhiteSpace = false;
		$domDocumentObj->formatOutput = false;

		echo module::help('usermng');
		$userMngModule = module::get('usermng', $this);
		$userMngModule->login('test', 'test');

		return false;
	}
}
				</pre>
Würde zunächst den Hilfetext des Plugins sessionManagement ausgeben und dann in der Methode des Logins unterbrechen und "Hurray iam loggedIn" ausgeben.<br><br>
			</p>
		</p>
		<h2>Hooks</h2>
		<a name="hooks"></a>
		<p>
				In Zukunft sollen für Plugin Entwickler verschiedene "Hook-Stops" verfügbar sein, um Models und Views während der Interpretation oder vor der Ausgabe manipulieren zu können.<br>
				Der in plugins/fileCompressed.php zu findende Code ist ein gutes bsp. für den ersten zu diesem Zeitpunkt implementierten Hook.<br>
				<h3>returnType</h3>
				<p>
					Die Drei, im unteren Teil zu findenden, noch sehr einfache Funktionen sollen Javascript, CSS oder XML Dokumente "minifyen" können.
					<pre style="padding:5px; background-color:lightgrey;">
&lt;?php

function CompressCss(&$objPage, $action) {
	$objPage->call($action);
...
				</pre>
				</p>
				returnType Hooks ersetzen den Teil der Ausgabe, vor dem Aufruf und der Verarbeitung, der Rückgabe von $objPage->call($action);.<br>
				<pre style="padding:5px; background-color:lightgrey;">
&lt;?php

hooks::addHook('returnType', 'CompressCss', 'CompressCss');
				</pre>
				Durch das hinzufügen vom Typ: "returnType" mit dem Namen "CompressCss" und der Funktion CompressCss, wird der returnType "CompressCss" als valider Parameter für die Action anerkannt.<br>
				<pre style="padding:5px; background-color:lightgrey;">
&lt;?php
&lt;action name="css" return="CompressCss"&gt;
	&lt;class&gt;HttpCache&lt;/class&gt;
	&lt;method&gt;compressAction&lt;/method&gt;
	&lt;style&gt;/styles/normalize.css;/base.css&lt;/style&gt;
&lt;/action>
				</pre>
				Sollte wie hier das Attribute return auf den durch hooks::addHook('returnType'... registrierten Wert gesetzt werden,<br>
				werden weitere Schritte zum verarbeiten der Ausgabe übersprungen und das Page Objekt mit allen Action Objekten an die Funktion übergeben und die Ausgabe beendet.<br>
					<pre style="padding:5px; background-color:lightgrey;">
&lt;?php
		$stylesheet = $objPage->getStylesheet($action);
		$files = explode(";", $stylesheet);
				</pre>
				Die Funktion ruft mit $objPage->call($action); die durch den zweiten Parameter bekannte, eigentlich vom System geroutete, Methode auf aber ignoriert die Ausgabe.<br>
				Durch den Aufruf von $objPage->getStylesheet($action); wird der Inhalt des Style Tags der aufgerufenen Action ausgelesen.<br>
				Im weiteren fügt es alle durch semikolen getrennten Dateien zu einem String zusammen und versucht diese mit möglichst wenig Overhead auszugeben.<br>
				Des weiteren Cached das Plugin die Ausgabe auf dem Server. Die gewählte Action aus der oben im Code zu findenden Controller Klasse, sendet sinnvolle Cacheing Header für den Client.<br>
				Natürlich kann auch eine andere Methode aus einem anderen Controller, angegeben werden. Der erstellte returnType führt diese aber nur aus und ignoriert den zurückgegebenen Wert biher komplett.
		</p>
		<a name="shortcuts"></a>
		<h2>Shortcuts</h2>
		<p>
			Es kommt häufig vor das Seiten einer Homepage, nur durch das Design abweichen aber der PHP Code auf ein paar Zeilen beschr&auml;nkt ist.<br>
			Wenn nur der &lt;style&gt; Tag von einer Action einen Unterschied ausmacht, muss weder eine vollt&auml;ndige Action noch eine weitere Methode implementiert werden:<br>
			<pre style="padding:5px; background-color:lightgrey;">
&lt;action name="agb" title="Allgemeine Geschäftsbedingungen"&gt;
	&lt;shortcut page="home"&gt;impressum&lt;/shortcut&gt;
	&lt;style&gt;impressum.html&lt;/style&gt;
&lt;/action&gt;
			</pre>
			Erstellt eine Action "agb" die auf die oben gezeigte (<a href="#elements">Elemente und Konstanten</a>) Action 'impressum' refenrenziert.<br>
			Dabei wird für die Action jegliche Option und vererbten Elemente von 'impressum', auch auf die Action 'agb' vererbt.
			Nehmen wir an die Methode publicPage() enthält ein Usertracking. Diese Methode wird quasi recycled aber Beim aufruf von loadPage mit einem anderen Stylesheet gerendert.<br>
			Es handelt sich beim &lt;shortcut&gt; Tag nicht um eine kosmetische Verbesserung. Beim Aufbau des Objekt Baums, welches nicht durch eine Action referenziert wird.<br>
			Wurde bereite ein Action Objekt mit dem Routing zur Methode 'publicPage' erstellt. Beim Parsen der Config, wird im Falle von nicht exakt angesteuerten Actions also kein weiteres Objekt Action und oder auch Page erneut erstellt.
			Ein 'shortcut' funktioniert auch, wenn eine Action mit:
			<pre style="padding:5px; background-color:lightgrey;">
&lt;?php

$document = new phtmlDocument();
$document->loadPage('home', 'impressum');
</pre>
			auferufen wird. Für gewöhnlich wird, wenn der Parameter Action exakt gesetzt wurde, nur ein rudiment&auml;rer Objekt Baum aufgebaut.<br>
			Die dient der Geschwindigkeit, den Castor lädt zwar nur was referenziert wird, aber muss einen Teil der Config geparst haben um zu wisssen was geladen werden muss.<br>
			Befindet sich die Action agb bspw. in einer page 'weiteres und diese wird direkt referneziert, wird dies erkannt und anhand von der definition von impressum nur ein Objekt Action erstellt.<br>
			Befinden sich beide Actions in der Page Home, wird für impressum ein Action Objekt erstellt und von Impressum referenziert. In den Attributen des Objekts wird nur der Stylesheet ausgetauscht.<br>
			Da nur entweder 'impressum' oder 'agb' aufgerufen werden kann, erkennt Castor welche Elemente sich unterscheiden und instanziert die Action wie gewünscht.<br>
			Die Angabe von 'file', 'class' und 'method' ist bei shortcuts nicht nötig.<br>
		</p>
		<a name="dependencys"></a>
		<h2>Dependencys (Abhängigkeiten)</h2>
		<p>
			Oft sind große Teile eines PHP Programms von einigen wenigen Variablen abhängig. Bspw. eine Datenbankverbindung möchte man nicht immer wieder erneut aufbauen.<br>
			In Objekt Orientierten Programmen, müssen diese aber meist über mehrere Klassen hinweg geteilt werden und dann wiederbenutzbar sein.<br>
			Wie jeder weis wird dies in OOP Programmen meist durch ein singleton Pattern gel&ouml;&szlig;t welches die weiter offene Datenbankverbindung zurückgibt.<br>
			Durch die Angabe von Elementen in der Konfiguration, könnten wie oben gezeigt schon in der Konfiguration Benutzerdaten oder anderes zur verf&uuml;gung gestellt werden.<br>
			Module die mit module::get geladen werden, sind für sich genommen Singleton Patterns und bleiben erhalten bis Inhalte per Hand gelöscht werden.<br>
			Ein Modul wie:<br>
			<pre style="padding:5px; background-color:lightgrey;">
class MysqlDB extends Surface {
	private $dbConstants = false;
	private $dbConnection = false;

	public function init() {
		$this->dbConstants = (object) $this->getElements('dbConstants');

		if(!$this->dbConstants->host) {
			$this->setError('Element host is not set!');

			return false;
		}
		if(!$this->dbConstants->username) {
			$this->setError('Element username is not set!');

			return false;
		}
		if(!$this->dbConstants->password) {
			$this->setError('Element password is not set!');

			return false;
		}
		if(!$this->dbConstants->dbname) {
			$this->setError('Element dbname is not set!');

			return false;
		}

		return true;
	}

	public function &connect() {
		if(!$this->dbConnection) {
			$this->dbConnection = new mysqli(
				$this->dbConstants->host,
				$this->dbConstants->username,
				$this->dbConstants->password,
				$this->dbConstants->dbname
			);

			if($this->dbConnection->connect_error) {
				throw new Exception('Connect Database Error: '.$this->dbConnection->connect_error);
			}

			$this->dbConnection->set_charset("utf8mb4");
		}

		return $this->dbConnection;
	}

	public function close() {
		if($this->dbConnection)
			$this->dbConnection->close();
		else
			return false;

		return true;
	}

	public function reset() {
		if(!$this->close())
			$this->setError('reset(), cannot reset closed Database Connection');

		$this->dbConstants = array();
		
		return $this->init();
	}
}
			</pre>
			Definiert mit:
			<pre style="padding:5px; background-color:lightgrey;">
&lt;surface name="mysqliConnection"&gt;
	&lt;arr name="dbConstants"&gt;
		&lt;var name="dbname"&gt;schema&lt;/var&gt;
		&lt;var name="host"&gt;127.0.0.1&lt;/var&gt;
		&lt;var name="username"&gt;user&lt;/var&gt;
		&lt;var name="password"&gt;passwort&lt;/var&gt;
	&lt;/arr&gt;
	&lt;file&gt;modules/mysqlidb.php&lt;/file&gt;
	&lt;class&gt;MysqlDB&lt;/class&gt;
&lt;/surface&gt;
			</pre>
			K&ouml;nnte beim initialisieren durch den &lt;load&gt; Tag, beim Aufbau der Page eine Datenbank Verbindung herstellen und durch:
			<pre style="padding:5px; background-color:lightgrey;">
$dbConnection = module::get('mysqliConnection', $this);
			</pre>
			Bereitstellen. Die connect Methode oben fängt zwar auch den mehrfachen Aufruf von connect auf, aber das Objekt im Speicher das von module::get zurückgegeben wird, wird sich nicht verändern.<br>
			Angenommen es liegt bereits ein ähnliches Modul vor und ein neues soll erstellt werden. Dann kann nach dem Laden des Moduls beliebig oft module::get aufgerufen werden.<br> 
			init() wird dabei nicht erneut ausgeführt, dazu wird onReady wie oben benutzt.<br>
			Ein anderes Modul soll braucht wahrscheinlich auch eine Datenbank Verbindung die in MysqlDB auch abstrahiert aufgebaut sein könnte.<br>
			Da der Objekt Baum auch in den Modulen zur Verfügung steht, kann der Abruf von jeglichen in diesem Kontext per &lt;load&gt; geladenen Modul auch dort erfolgen.<br>
			Bspw. könnte eine Klasse für das Rechte Management einer Seite eine Datenbank Verbindung benötigen.<br>
			<pre style="padding:5px; background-color:lightgrey;">
class user extends sessionManagement {
	private $mysqli;

	public function onReady() {
		$dbConnection = module::get('mysqliConnection', $this);
		$this->mysqli = $dbConnection->connect();

		return true;
	}
}
			</pre>
			Wenn sowohl 'mysqliConnection' als auch 'user', durch den &lt;load&gt; Tag geladen wurden kann ein Controller bspw so:<br>
			<pre style="padding:5px; background-color:lightgrey;">
public function myMethod() {
	$dbConnection = module::get('mysqliConnection', $this);
	$mysqli = $dbConnection->connect();
}
			</pre>
			Eine Mysql Connection aufbauen...<br>
			Wird daraufhin:<br>
			<pre style="padding:5px; background-color:lightgrey;">
$user = module::get('user', $this);
			</pre>
			Aufgerufen, wird die Datenbank Verbindung in user->onReady nicht erneut aufgebaut, sondern wie beim Singleton Pattern wiederverwendet.<br>
			Es ist wichtig zu verstehen das die &connect() Methode nur zur Sicherheit abf&auml;ngt ob die Verbindung bereits besteht.<br>
			Die Nutzung in 'user' währe auch möglich, wenn connect() nicht erneut aufgerufen wird.<br><br>
			Um bei selbst erstellten Konstrukten wie einer Benutzerverwaltung auch neu Einsteigern in den Code, zu erleichtern eine Action mit dem Modul 'user' anzulegen.<br>
			Kann oben im &lt;document&gt; Tag das Modul Konstrukt mit einem &lt;dependency&gt; Tag versehen werden:<br>
			<pre style="padding:5px; background-color:lightgrey;">
&lt;operator name="user"&gt;
	&lt;dependency type="surface"&gt;mysqliConnection&lt;/dependency&gt;
	&lt;file&gt;modules/user.php&lt;/file&gt;
	&lt;class&gt;user&lt;/class&gt;
	&lt;arr name="constants"&gt;
		&lt;var name="fixuseragent"&gt;yes&lt;/var&gt;
		&lt;var name="maxlifetime"&gt;yes&lt;/var&gt;
		&lt;var name="forwardsecrecy"&gt;yes&lt;/var&gt;
	&lt;/arr&gt;
&lt;/operator&gt;
			</pre>
			Das hat zur folge, das ein Programmierer der eine neue Action mit einer Userverwaltung deployen möchte, das Modul nur laden kann, wenn auch mysqliConnection geladen wurde.<br>
			Das Page Objekt reagiert mit:
			<pre style="padding:5px; background-color:lightgrey;">
throw new Exception("Dependency mysqliConnection not found!");
			</pre>
			Wenn mit &lt;load&gt;user&lt;/load&gt; 'user' geladen werden soll, aber 'mysqliConnection' nicht geladen wurde.<br>
			&Auml;hnlich den HELP Konstanten eine strukturierte Abfrage, die nur bei Modularer Entwicklung einen echten mehrwert verspricht.<br>
		</p>
	</body>
</html>